#websec #appsec #web-security-academy
#Authentication-vulnerabilities
## Brute-force attacks

- **Usernames**:  
	Facilmente reconocibles si estan armados por un patron, firstname.lastname@pepito[.]com
	Revisar si hay potenciales usernames publicos
	Revisar respuestas HTTP para ver si vemos algun email, ocacionalmente podemos encotnrar una cuenta con privilegios altos.

- **Passwords**
	Suele haber politicas sobre robustes de contraseña.
	Se suele usar diccionarios o rainbowtables.
	Es comun ver que `mypassword` no es usable, pero si `Mypassword1!` or `Myp4$$w0rd`
	Si suele haber una politica de cambio de contraseñas, suelen ser cambios minimos. `Mypassword1!` pasa a ser `Mypassword1?` o `Mypassword2!.`

### Useraname Enumeration:
#enumeration 
- **Status Code:**  El status code de una respuesta HTTP puede variar si el username es correcto.
- **Error messages:** El mensaje de error puede variar dependiendo de su usuario y contraseña son incorrectos o si solo la contraseña es incorrecta
- **Response Time:** El tiempo de respuesta puede variar cuando el usuario es valido, hay veces que la aplicacion hace un llamado a la db para checkear si el usuario existe y posterior a esto verifica la contraseña, esto te da una diferencia temporal cuando el usuario es incorrecto o no.

- LAB [Username enumeration via different responses](https://portswigger.net/web-security/authentication/password-based/lab-username-enumeration-via-different-responses) 
- LAB [Username enumeration via subtly different responses](https://portswigger.net/web-security/authentication/password-based/lab-username-enumeration-via-subtly-different-responses)
- LAB [Username enumeration via response timing](https://portswigger.net/web-security/authentication/password-based/lab-username-enumeration-via-response-timing)

### Vulnerando protecciones contra brute-force

Las 2 medidas mas comunes:
- Bloquear la cuenta a la que el usuario remoto está intentando acceder si realizan demasiados intentos de inicio de sesión fallidos.
- Bloquear la dirección IP del usuario remoto si realizan demasiados intentos de inicio de sesión en rápida sucesión.

#### IP-block
Algunas veces se suele bloquear la ip cuando se tiene muchos intentos fallidos. En algunas implementaciones el contador se reinicia cuando hay un logeo correcto, para esto se recomienda poner unas credenciales validas cada cierta cantidad de intentos.

- LAB [Broken brute-force protection, IP block](https://portswigger.net/web-security/authentication/password-based/lab-broken-bruteforce-protection-ip-block)

#### Account Locking
Se suele bloquear la cuenta con cierto numero de intentos fallidos. Esto sirve para enumerar un usuario
- LAB [Username enumeration via account lock](https://portswigger.net/web-security/authentication/password-based/lab-username-enumeration-via-account-lock)

Este metodo puede ser bypasseado utilizando #password-spraying o #credentials-stuffing. 
Tambien hay otra tecnica como:
1. Establecer una lista de posibles usuarios validos, ya sea enumerando usuarios o eligiendo usernames comunes.
2. Elegir una corta lista de passwords que un usuario de estos podria usar. El numero de passwords a probar no debe superar el numero de intentos que nos permite la app.
3. Iterar cada username con cada contraseña

#### User rate limiting
Metodo que limita la cantidad de peticiones del usuario en un corto periodo de tiempo, si lo superamos nos bloqueara la IP. La misma se desbloquea de alguna de las siguientes maneras:
- Automaticamente despues de cierto tiempo.
- Manualmente mediante un Admin
- Manualmente despues de completar un CAPTCHA.

Formas de eludir la defensa puede ser:
- Tampering de la IP en la request HTTP
- Enviar multiples contraseñas en una sola solicitud HTTP.


- LAB [Broken brute-force protection, multiple credentials per request](https://portswigger.net/web-security/authentication/password-based/lab-broken-brute-force-protection-multiple-credentials-per-request)

si vemos que manda las solicitudes en formato JSON, podemos enviar lo siguiente:
```json
"`username" : "carlos", 
"password" : [ "123456", 
			  "password", 
			  "qwerty" ... 
			  ]
```
una vez enviada, nos retornara 302 si una de ellas es correcta. buscamos visualizar la respuesta en el browser, y estaremos dentro.

### HTTP basic authentication

El cliente recibe un token de autenticacion del server, que es construido concatenando el username y password y encodeado en b64. Se guarda en el browser y se agrega como Authorization header en cada request siguiente.
`Authorization: Basic base64(username:password)`
- Se envia la request en cada peticion
- Si el sitio no usa HSTS, las credenciales pueden ser interceptadas por un MitM
- Pueden ser bruteforceadas al ser valores estaticos.
- Vulnerable a exploits relacionado a sessiones, especialmente #CSRF