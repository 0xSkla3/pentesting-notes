#API #websec #web-security-academy #recon #api-recon #mass-assignment
# Recon

 - Identificar los EP y como se interactua con ellos
	 - Los datos de entrada que procesa la API, incluidos los parámetros obligatorios y opcionales.  
	 - Los tipos de solicitudes que acepta la API, incluidos los métodos HTTP y formatos de medios admitidos.  
	 - Los límites de velocidad y los mecanismos de autenticación.

Ej:

```http
GET /api/books HTTP/1.1 Host: example.com
GET /api/books/mistery HTTP/1.1 Host: example.com
GET /api/books/1 HTTP/1.1 Host: example.com
```
# API Documentation

Hay 2 tipos de documentacion, una legible para humanos y otra para maquinas, esta ultima viene en formatos estructurados como xml, json, yaml, etc.

Si no hay documentacion publica, se puede navegar la aplicacion que haga uso de ella mientras se usa un Web Proxy como `BurpSuite`o `owasp ZAP`.


## Descubiriendo API documentation

Prestar atencion a los EP que puedan ser de documentacion como:

- `/api`
- `/swagger/index.html`
- `/openapi.json`

Si se detecta un EP de un recurso, vaya investigando los paths base anteriores:

Ejemplo: 

> `/api/swagger/v1/users/123`
>  - `/api/swagger/v1`
>  - `/api/swagger`
>  - `/api`

## Usar documentacion machine-redeable

Se puede usar una gran variedad de aplicaciones. Dentro de burp se puede usar [OpenAPI Parser](https://portswigger.net/bappstore/6bf7574b632847faaaa4eb5e42f1757c) Bapp.

Para probar los EP se puede usar Postman o Insomnia

# Identificando  EPs

- Crawlear la web para identificar posibles EP a la API
- Revisar archivos js, pueden contener EP que no se puedan trigerear desde la web. El Burp Scaner detecta algunos por defecto, para algo mas profundo usar [JS Link Finder](https://portswigger.net/bappstore/0e61c786db0c4ac787a08c4516d52ccf) BApp.
- Poner otras tools para api recon
- 

## Interactuando con los EPs

se puede utilizar el burp intruder, repeater... u otro webproxy. Investigar el comportamiento y descubrir nueva superficie de ataque. Ej: se puede cambiar los media type, cambiar los metodos HTTP y observar de cerca las respuestas de error que pueden ser utilizadas para craftear peticiones validas.

### Identificando metodos HTTP validos

[Metodos HTTP](https://developer.mozilla.org/es/docs/Web/HTTP/Methods)


| Metodo | ¿Que hace? |
| - | - |
| [`GET`](https://developer.mozilla.org/es/docs/Web/HTTP/Methods/GET) | El método `GET` solicita una representación de un recurso específico.| 
|[`HEAD`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD "Esta página está disponible solo en inglés")|El método `HEAD` pide una respuesta idéntica a la de una petición GET, pero sin el cuerpo de la respuesta.|
|[`POST`](https://developer.mozilla.org/es/docs/Web/HTTP/Methods/POST)|El método `POST` se utiliza para enviar una entidad a un recurso en específico, causando a menudo un cambio en el estado o efectos secundarios en el servidor.|
|[`PUT`](https://developer.mozilla.org/es/docs/Web/HTTP/Methods/PUT)|El modo `PUT` reemplaza todas las representaciones actuales del recurso de destino con la carga útil de la petición.|
|[`DELETE`](https://developer.mozilla.org/es/docs/Web/HTTP/Methods/DELETE)|Borra un recurso en específico.|
|[`CONNECT`](https://developer.mozilla.org/es/docs/Web/HTTP/Methods/CONNECT)|Establece un túnel hacia el servidor identificado por el recurso.|
|[`OPTIONS`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS "Esta página está disponible solo en inglés")|Recupera información sobre los tipos de métodos de solicitud que se pueden utilizar en un recurso.|
|[`TRACE`](https://developer.mozilla.org/es/docs/Web/HTTP/Methods/TRACE)|Realiza una prueba de bucle de retorno de mensaje a lo largo de la ruta al recurso de destino.|
|[`PATCH`](https://developer.mozilla.org/es/docs/Web/HTTP/Methods/PATCH)|Aplica modificaciones parciales a un recurso|

Ej de EP: `/api/tasks`

- `GET /api/tasks`
- `POST /api/tasks`
- `DELETE /api/tasks/1`

> Nota
> Cuando se testea diferentes metodos HTTP, hacerlo en recursos de baja prioridad asi evitamos consecuencias inintencionadas, como alterar datos criticos o crear/borrar registros excesivos


### Identificando content types admitidos

Cambiando los `Content-Type` podemos
- Provocar errores que den informacion util
- Bypasear defensas defectuosas
- Aprovechar diferencias en la logica de procesamiento. Ej: una api es segura cuando maneja datos de tipo **JSON** pero es inyectable cuando usa **XML**  

Para esto, hay que modificar el header `Content-Type` y reformatear el body.
Se puede usar [Content type converter](https://portswigger.net/bappstore/db57ecbe2cb7446292a94aa6181c9278) BApp para convertir automaticamente los datos entre **XML**  y **JSON**.


> LAB: [Finding and exploiting an unused API endpoint](https://portswigger.net/web-security/api-testing/lab-exploiting-unused-api-endpoint)


### Identificar EPs ocultos


- Ej: `PUT /api/user/update`
	- Se podria modificar el `/update` por otra lista de otras funciones comunes, como `delete` o `add`, tambien modificar el metodo HTTP

> **NOTA:** utilizar diccionarios basados en nomenclatura y nombres convencionales para la industria, sus objetos y terminos especificos.


# Buscando parametros ocultos

- Con Burpsuite
	- Burp Intruder te permite cargar una lista de parametros y reemplazar o agregar sobre los existentes, asegurarse de incluir en la lista los relevantes basados en el recon inicial
	- [Param miner](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) BApp permite enviar hasta 65536 parametros por request, y adivina automaticamente los paramentros relevantes basandose en la informacion tomada del scope.
	- El [Content discovery](https://portswigger.net/burp/documentation/desktop/tools/engagement-tools/content-discovery) te permite descubrir contenidos que no están vinculados a contenido visible, incluyendo parametros.


### Mass assignment vuln

Tambien conocida como auto-binding o auto-mapping, permite el manipular parametros ocultos. Esto ocurre cuando el framework mapea automaticamente parametros a campos de un objeto interno de la API.

#### Identificando parametros ocultos

Se pueden identificar algunos parametros manualmente examinando los objetos que retorna la API en el response.

Ej:  se manda un `PATCH /api/users/` a 

```json
{
	"username": "wiener", 
	"email": "wiener@example.com"
}
```

y tenemos una request `GET /api/users/123`

```json
{
	"id": 123, 
	"name": "John Doe", 
	"email": "john@example.com", 
	"isAdmin": "false" 
}
```

esto indíca los parametros ocultos `id` y `isAdmin` que estan relacionados con el objeto interno `user`.

#### Testeando mass assignment

Modificamos el campo `isAdmin` en la request `PATCH`

`PATCH /api/users/`

```json
{
	"username": "wiener", 
	"email": "wiener@example.com",
	"isAdmin": "foo"
}
```

Si la aplicacion se comporta distinto, esto puede sugerir que el valor no valido afecta en la logica de la peticion, pero no es el valor adecuado. Esto puede indicar que el parametro puede ser modificado.

`PATCH /api/users/`

```json
{
	"username": "wiener", 
	"email": "wiener@example.com",
	"isAdmin": true
}
```

Validamos si tenemos permisos en funcionalidades administrativas.

> LAB  [Exploiting a mass assignment vulnerability](https://portswigger.net/web-security/api-testing/lab-exploiting-mass-assignment-vulnerability)

## Previniendo vulnerabilidades en APIs

- Asegurar la documentacion si no deberia ser accedida publicamente.
- Tener la documentacion actualizada para que los pentesters tengan visibilidad completa de la superficie de ataque.
- Aplicar un listado permitido de metodos HTTP.
- Validar que el content type es el esperado por acada request y response.
- Utilice mensajes de error genéricos para evitar dar información que pueda ser útil para un atacante.
- Utilizar medidas de protección en todas las versiones de la API, no sólo en producción.

> **NOTA:** Para evitar `mass assignment`, liste los parametros que pueden ser actualizados y bloquee los sensibles que no deberia poder actualizar.

